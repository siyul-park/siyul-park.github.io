---
title: "Go에서의 가비지 컬렉션"
date: 2024-02-24 12:00:00 +0900
categories: "system"
tags: ["system", "golang", "garbage-collection"]
---

Go는 정적 타입 컴파일 언어의 효율성을 유지하면서도 동적 언어처럼 사용하기 쉽도록 설계되었습니다.

빠른 컴파일 속도와 함께 덕 타이핑(Duck Typing)과 런타임 리플렉션(Reflection)을 지원하여 동적 언어를 사용하는 것과 유사한 경험을 제공합니다. 그리고 적은 수의 예약어를 사용하고 간결하고 단순한 언어를 지향하여 코드를 이해하고 관리하는데 들어가는 비용을 줄입니다. 더불어 매우 작은 크기의 스택(2KB)과 프로그램 카운터(PC) 및 스택 포인터(SP)만을 차지하는 경량 스레드인 고루틴(Goroutine)과 고루틴 간 쉬운 데이터 전달을 위한 채널(Channel)을 통해 높은 수준의 동시성(Concurrency) 모델을 제공합니다.

메모리 관리는 수천개의 고루틴이 동시에 실행되더라도 안전하고 효율적으로 작동해야 했습니다. 이를 위해 높은 비용이 드는 원자성 연산이 필요한 레퍼런스 카운팅(Reference Counting) 대신 CMS(Concurrent Mark Sweep) 방식의 GC(Garbage Collection)를 사용합니다. 또한 Go는 가상 머신에서 돌아가는 언어가 아니므로 런타임에 관련된 모든 기능이 실행 파일에 내장되어 GC를 포함한 런타임의 기능은 오버헤드를 줄이기 위해 최대한 간결하게 작성되어야 했습니다.

## 메모리 구조

초창기 GC는 매우 끔찍한 성능을 보여주었습니다. 전체 CPU 자원의 25%를 사용하며 50ms 마다 STW가 발생하여 10ms 동안 런타임이 정지되었습니다. Read Barrier Free Concurrent Coping GC로 개선이 시도되었지만 C로 짜여진 런타임을 GO로 재작성하고 컴파일러의 성능을 개선시키는 것이 우선되어, 병렬적으로 GC가 실행이 가능하도록 변경하는데 그쳤습니다.

이후에는 압축 대신 TCMalloc을 기반으로 한 자체 메모리 관리가 도입되었습니다.

### mspan

이 방식은 메모리를 67가지 다른 크기의 페이지 블록들로 분리합니다. 그런 다음, 동일한 크기의 페이지 블록들을 묶어 페이지의 시작 주소, 크기 및 포함된 페이지 수, sweep 상태를 가지는 이중 연결 목록 개체인 `mspan`으로 구성합니다.

```
+--------------+--------------+------------------+--------------------+-----------------+----------+-----+
| prev: *mspan | next: *mspan | spanClass: uint8 | startAddr: uintptr | npages: uintptr | sweepgen | ... |
+--------------+--------------+------------------+--------------------+-----------------+----------+-----+
```

동일한 페이지 크기에 대해 포인터를 가지는 객체들을 저장하는 `scan`과 포인터가 없어 객체의 의존성을 더 탐색하지 않아도 되는 `nonscan`가 존재합니다.

### mcache

그리고 각각의 고루틴에서 잠금 없이 빠르게 메모리를 할당하기 위해 로컬 스레드 캐쉬인 `mcache`가 존재합니다. 

```
+---------------+------------------------------------+-------------------------------------------+-----+
| tiny: uintptr | alloc: [_NumSizeClasses * 2]*mspan | stackcache [_NumStackOrders]stackfreelist | ... |
+---------------+------------------------------------+-------------------------------------------+-----+
```

`mcache`는 크기와 수명이 정해진 객체들을 저장하는 `stackcache`와 16B 보다 작은 객체를 저장하기 위한 `tiny` 그리고 32KB보다 작은 값을 저장하기 위한 `alloc`을 가지고 있습니다. 사용가능한 `mspan`이 없으면 `mcentral`에 요청하여 새로운 `mspan`을 할당받습니다.

### mcentral

동일한 페이지 크기를 가지는 모든 `mspan`들은 `mcentral`로 그룹화 됩니다. `mcentral`은 비어 있는 페이지가 존재하여 할당이 가능한 `partial`과 더 이상 할당이 불가능한 `full`을 가지고 있습니다.

```
+--------------+--------------+------------------+--------------------+-----------------+----------+-----+
| prev: *mspan | next: *mspan | spanClass: uint8 | startAddr: uintptr | npages: uintptr | sweepgen | ... |
+--------------+--------------+------------------+--------------------+-----------------+----------+-----+
```

`partial`와 `full`은 정리되지 않은 `mspan`들과 정리된 `mspan`들로 이뤄져 있습니다. 이 두 그룹은 가비지 컬렉션 과정에서 서로 역할을 교환합니다. 메모리가 아직 사용 중이면 정리되지 않은 그룹에서 메모리를 가져와서 정리된 그룹에 추가합니다. 또한 메모리가 할당되면 정리된 그룹에 추가됩니다.

## 참고 자료
- [A Guide to the Go Garbage Collector](https://tip.golang.org/doc/gc-guide)
- [A visual guide to Go Memory Allocator from scratch (Golang)](https://medium.com/%2540ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed)
