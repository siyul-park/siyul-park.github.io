---
title: "그래서 객체지항이란 무엇인가요?"
date: 2024-05-31 12:00:00 +0900
categories: "pattern"
tags: ["pattern", "oop"]
---

1967년 5월, 크리스틴 니갈(Kristen Nygaard)과 올 요한 다히(Ole-Johan Dahl)는 오슬로에서 열린 IFIP 시뮬레이션 언어 실무 회의에서 클래스와 서브클래스 선언에 관한 논문을 발표했습니다. 이 논문은 객체지향 기능이 추가된 Simula 67의 첫 번째 공식 정의가 되었습니다.

1970년대에는 미국 제록스(Xerox)사의 팔로 알토 연구센터(PARC)에서 앨런 케이(Alan Kay)와 그의 팀이 순수 객체지향 언어인 Smalltalk를 개발했습니다. Smalltalk는 동적 타이핑과 인터프리터 방식을 특징으로 하며, 언어 수준에서의 객체지향 지원과 편리한 그래픽 개발 환경으로 주목받았습니다. 다양한 버전을 거치며 발전한 Smalltalk는 Simula 67의 아이디어에 영향을 받았지만, 클래스가 동적으로 생성되고 수정될 수 있게 확장되었습니다.

1979년에 개발된 Lisp는 다중 상속과 믹스인을 도입했습니다. 1980년대 중반에는 브래드 콕스(Brad Cox)가 Smalltalk에 영향을 받아 Objective-C를 개발했고, 1985년 비야네 스트로스트룹(Bjarne Stroustrup)은 C 언어를 바탕으로 객체지향 기능을 추가하여 C++를 만들었습니다.

결국, 1990년대 초반과 중반에 객체지향 프로그래밍은 지배적인 패러다임으로 발전했습니다.

## 그래서 객체지향이란 무엇인가요?

함수형 프로그래밍을 비롯한 여러 패러다임이 탄생했지만, 객체지향 프로그래밍은 여전히 가장 보편적인 패러다임으로 자리 잡고 있습니다. 그러나 이 패러다임은 명확하게 정리된 경우가 드물며, 주로 경험을 바탕으로 직관적으로 접근되거나 SOLID와 같은 파생된 원칙과 패턴들로 규정됩니다.

초창기의 프로그램은 매우 특화된 한 가지 작업만 처리했습니다. 하지만 컴퓨팅 비용이 점점 저렴해지면서 컴퓨터는 더욱 다양한 역할을 수행하게 되었고, 이에 따라 프로그램도 점차 복잡해졌습니다. 너무나 복잡해진 프로그램은 인간의 인지 능력에 부하를 주었고, 이는 수많은 오류와 생산성 저하로 이어졌습니다. 이러한 문제를 해결하기 위해 다익스트라(Dijkstra)는 그의 논문 "[GOTO 문의 해로움](https://web.archive.org/web/20070703050443/http://www.acm.org/classics/oct95/)"에서 구조적 프로그래밍에 대한 논의를 시작했습니다.

구조적 프로그래밍은 프로그램을 간단하고 계층적인 제어 구조로 분리했습니다. 이를 위해 `GOTO` 문을 제거하여 코드의 흐름과 실행 흐름을 동일하게 만들었고, 프로그램을 작은 단위의 구조로 분할할 수 있게 되었습니다. 입증 가능한 순차, 선택, 반복의 조합으로 시작된 프로시저는 서로 합쳐져 큰 기능을 가진 프로그램을 구성하게 되었습니다. 이러한 방식은 복잡한 프로시저를 만들 때 한 단계 낮은 하위 프로시저의 기능에만 집중할 수 있게 하여, 개발자가 한 번에 인지해야 하는 개념을 줄여주었습니다.

전통적인 구조적 프로그래밍이 추상화를 제공했지만, 하위 프로시저와 연관된 모든 기능은 상위 프로시저가 제어해야 했습니다. 더 추상적인 상위 프로시저는 그보다 작고 구체적인 프로시저의 실제적 구현에 의존하고 있었으며, 완전한 분리가 이루어지지 않았습니다. 하위 프로시저가 가지는 너무나 구체적인 제어 플래그들은 추상화를 넘어서 상위 프로시저에까지 흘러오게 되었고, 이는 프로시저를 재사용하기 어렵고 복잡하게 만들었습니다.

객체지향은 프로그램을 상태와 연산을 가지는 객체로 분리했습니다. 객체의 상태에 따라 연산을 동적으로 제어될 수 있게 되면서, 어떤 프로시저가 사용되는지 알지 않아도 호출자는 객체의 상태에 따라 연산을 간접적으로 호출할 수 있게 되었고, 실제 구현에 의존하지 않고 더 고수준의 인터페이스에 의존하게 되어 각 모듈이 독립적이고 확장하기 쉽게 만들어졌습니다.

이러한 다형성으로 인해 세부 구현은 객체 내부로 캡슐화되어 개념의 추상화가 이루어졌습니다. 객체들은 서로 동일한 수준에서 협력할 수 있게 되었고, 더 구체적인 연산에 의존하지 않게 되어 프로그램의 복잡도를 유지하며 기능을 확장할 수 있게 되었습니다.

## 객체지항의 접근

이렇게 다양한 객체들이 프로그램 안에 존재하게 되면서, 객체들 간의 관계를 정의하여 재사용성을 높일려는 시도들이 나오게 되었습니다.

과거 아리스토텔레스는 세상에 존재하는 모든 사물들을 공유하는 속성과 능력을 기반으로 분류했습니다. 다양한 개체들 중에서도 이들이 공통적으로 공유하는 속성을 통해 하나의 추상적인 범주를 만들 수 있다고 생각했습니다. 이러한 추상적인 범주는 모든 객체의 본질이며, 이는 현상 세계 밖의 세상인 이데아에 해당합니다.

이러한 방식이 객체지향 프로그래밍에 녹아들어, 공통의 속성과 동작을 가진 객체들을 본질적인 클래스로 정의하게 됩니다. 이러한 클래스는 인스턴스화를 통해 실행 환경에서 보편적으로 접근 가능한 객체가 됩니다. 이렇게 만들어진 클래스들 사이에서도 비슷한 일이 일어납니다. 더 근원적인 상위 클래스는 이상적인 본질을 나타내며, 하위 클래스는 이 본질을 확장하고 구체화합니다. 하위 클래스는 상위 클래스를 상속하여 공통적인 특성을 물려받으면서도, 고유한 특성과 행동을 추가하여 보다 구체적이고 독립적인 존재로 나타나게 됩니다.

## 참고 문서

- [자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/%2540limsungmook/%25EC%259E%2590%25EB%25B0%2594%25EC%258A%25A4%25ED%2581%25AC%25EB%25A6%25BD%25ED%258A%25B8%25EB%258A%2594-%25EC%2599%259C-%25ED%2594%2584%25EB%25A1%259C%25ED%2586%25A0%25ED%2583%2580%25EC%259E%2585%25EC%259D%2584-%25EC%2584%25A0%25ED%2583%259D%25ED%2596%2588%25EC%259D%2584%25EA%25B9%258C-997f985adb42)
- [Object-oriented programming - Wikipedia](https://en.m.wikipedia.org/wiki/Object-oriented_programming)
